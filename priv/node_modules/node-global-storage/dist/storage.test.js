"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const strict_1 = __importDefault(require("node:assert/strict"));
const node_test_1 = require("node:test");
const storage_lib_1 = require("./storage.lib");
const restartStorage = () => (0, storage_lib_1.flush)({ silent: true });
(0, node_test_1.describe)("SET function", () => {
    (0, node_test_1.it)("Sets a value with default parameters and returns it", () => {
        restartStorage();
        const key = "myKey";
        const value = "This is my value";
        const result = (0, storage_lib_1.set)(key, value);
        const expectedResult = value;
        strict_1.default.strictEqual(expectedResult, result);
    });
    (0, node_test_1.it)("Sets a protected value and returns it", () => {
        restartStorage();
        const key = "myKey";
        const value = "This is my protected value";
        const result = (0, storage_lib_1.set)(key, value, { protected: true });
        const expectedResult = value;
        strict_1.default.strictEqual(expectedResult, result);
    });
    (0, node_test_1.it)("Does not overwrite a protected value without being forced", () => {
        restartStorage();
        const key = "myKey";
        const oldValue = "This is my protected value";
        const newValue = "This is my overwritten value";
        (0, storage_lib_1.set)(key, oldValue, { protected: true });
        const result = (0, storage_lib_1.set)(key, newValue);
        const expectedResult = oldValue;
        strict_1.default.strictEqual(expectedResult, result);
    });
    (0, node_test_1.it)("Does overwrite a protected value when forced", () => {
        restartStorage();
        const key = "myKey";
        const oldValue = "This is my protected value";
        const newValue = "This is my overwritten value";
        (0, storage_lib_1.set)(key, oldValue, { protected: true });
        const result = (0, storage_lib_1.set)(key, newValue, { force: true });
        const expectedResult = newValue;
        strict_1.default.strictEqual(expectedResult, result);
    });
});
(0, node_test_1.describe)("LIST function", () => {
    (0, node_test_1.it)("Lists all values without options or callbacks", () => {
        restartStorage();
        const key1 = "key_1";
        const value1 = "value_1";
        (0, storage_lib_1.set)(key1, value1);
        const key2 = "key_2";
        const value2 = "value_2";
        (0, storage_lib_1.set)(key2, value2);
        const result = (0, storage_lib_1.list)();
        const expectedResult = {
            [key1]: value1,
            [key2]: value2,
        };
        strict_1.default.deepStrictEqual(result, expectedResult);
    });
    (0, node_test_1.it)("Lists all values values with extended data", () => {
        restartStorage();
        const key1 = "key_1";
        const value1 = "value_1";
        const onUpdate1 = () => 1;
        (0, storage_lib_1.set)(key1, value1, { onUpdate: onUpdate1 });
        const key2 = "key_2";
        const value2 = "value_2";
        (0, storage_lib_1.set)(key2, value2);
        const listedValues = (0, storage_lib_1.list)({ extended: true });
        const result = Boolean(listedValues[key1].onUpdate);
        const expectedResult = true;
        strict_1.default.strictEqual(result, expectedResult);
    });
});
(0, node_test_1.describe)("isSet function", () => {
    (0, node_test_1.it)("Returns true when a key is set", () => {
        restartStorage();
        const key1 = "key_1";
        const value1 = "value_1";
        (0, storage_lib_1.set)(key1, value1);
        const result = (0, storage_lib_1.isSet)(key1);
        const expectedResult = true;
        strict_1.default.strictEqual(result, expectedResult);
    });
    (0, node_test_1.it)("Returns false when a key is not set", () => {
        restartStorage();
        const key1 = "key_1";
        const value1 = "value_1";
        (0, storage_lib_1.set)(key1, value1);
        const key2 = "key_2";
        const result = (0, storage_lib_1.isSet)(key2);
        const expectedResult = false;
        strict_1.default.strictEqual(result, expectedResult);
    });
});
(0, node_test_1.describe)("UNSET function", () => {
    (0, node_test_1.it)("Unsets a value that exists", () => {
        restartStorage();
        const key1 = "key_1";
        const value1 = "value_1";
        (0, storage_lib_1.set)(key1, value1);
        (0, storage_lib_1.unset)(key1);
        const result = (0, storage_lib_1.isSet)(key1);
        const expectedResult = false;
        strict_1.default.strictEqual(result, expectedResult);
    });
    (0, node_test_1.it)("Unsets a value that does not exists without crashing", () => {
        restartStorage();
        const key1 = "key_1";
        (0, storage_lib_1.unset)(key1);
        const result = (0, storage_lib_1.isSet)(key1);
        const expectedResult = false;
        strict_1.default.strictEqual(result, expectedResult);
    });
});
(0, node_test_1.describe)("FLUSH function", () => {
    (0, node_test_1.it)("Flushes all values", () => {
        const key1 = "key_1";
        const value1 = "value_1";
        (0, storage_lib_1.set)(key1, value1);
        const key2 = "key_2";
        const value2 = "value_2";
        (0, storage_lib_1.set)(key2, value2);
        (0, storage_lib_1.flush)();
        const result = !(0, storage_lib_1.isSet)(key1) && !(0, storage_lib_1.isSet)(key2);
        const expectedResult = true;
        strict_1.default.strictEqual(result, expectedResult);
    });
});
(0, node_test_1.describe)("isProtected function", () => {
    (0, node_test_1.it)("Returns true when a key is protected", () => {
        restartStorage();
        const key1 = "key_1";
        const value1 = "value_1";
        (0, storage_lib_1.set)(key1, value1, { protected: true });
        const result = (0, storage_lib_1.isProtected)(key1);
        const expectedResult = true;
        strict_1.default.strictEqual(result, expectedResult);
    });
    (0, node_test_1.it)("Returns false when a key is not protected", () => {
        restartStorage();
        const key1 = "key_1";
        const value1 = "value_1";
        (0, storage_lib_1.set)(key1, value1);
        const result = (0, storage_lib_1.isProtected)(key1);
        const expectedResult = false;
        strict_1.default.strictEqual(result, expectedResult);
    });
});
